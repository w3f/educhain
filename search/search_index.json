{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web3 Educhain Educating Web3 through Polkadot SDK. Why Educhain? When creating Web3 Educhain project, there were around 50 parachains on the Polkadot network but no concrete guides on launching a production-grade parachain and its maintenance. Also, there are very limited tutorials that demonstrate Polkadot SDK features that are shipped with FRAME library. Web3 Educhain intends to address these issues. Why Polkadot? Along with the efficient utility of coretime and blockspace, a parachain deployed on Polkadot has access to Multi-billion dollar crypto-economic security backed finality from block number one. Secure interoperability with multiple chains within and outside of the Polkadot ecosystem. Customizable blockchain runtimes written in Rust and executed as Wasm code. Decentralized network and networking stack with light-client prioritized design. Visionary, intellectual, smart (and at times oversmart) developer community. Polkadot OpenGov and its Treasury, which pays OECD grade salaries to the Technical Fellowship and funds numerous development initiatives through bounties. With Agile Coretime, para chains can now produce blocks continuously or on demand. By activating Async Backing feature, parachains can produce blocks every 6 seconds whose transactions get finalized in 20-60 seconds, and around 800 TPS . With elastic scaling feature, the throughput of parachains is expected to improve further. In the near future, parachains can subscribe to the parachains service of JAM chain which enables advanced features that makes blockchain technology feasible for majority of its usecases. You can now launch a production-grade blockchain in a day! To learn how, navigate to the next page.","title":"Web3 Educhain"},{"location":"#web3-educhain","text":"Educating Web3 through Polkadot SDK.","title":"Web3 Educhain"},{"location":"#why-educhain","text":"When creating Web3 Educhain project, there were around 50 parachains on the Polkadot network but no concrete guides on launching a production-grade parachain and its maintenance. Also, there are very limited tutorials that demonstrate Polkadot SDK features that are shipped with FRAME library. Web3 Educhain intends to address these issues.","title":"Why Educhain?"},{"location":"#why-polkadot","text":"Along with the efficient utility of coretime and blockspace, a parachain deployed on Polkadot has access to Multi-billion dollar crypto-economic security backed finality from block number one. Secure interoperability with multiple chains within and outside of the Polkadot ecosystem. Customizable blockchain runtimes written in Rust and executed as Wasm code. Decentralized network and networking stack with light-client prioritized design. Visionary, intellectual, smart (and at times oversmart) developer community. Polkadot OpenGov and its Treasury, which pays OECD grade salaries to the Technical Fellowship and funds numerous development initiatives through bounties. With Agile Coretime, para chains can now produce blocks continuously or on demand. By activating Async Backing feature, parachains can produce blocks every 6 seconds whose transactions get finalized in 20-60 seconds, and around 800 TPS . With elastic scaling feature, the throughput of parachains is expected to improve further. In the near future, parachains can subscribe to the parachains service of JAM chain which enables advanced features that makes blockchain technology feasible for majority of its usecases. You can now launch a production-grade blockchain in a day! To learn how, navigate to the next page.","title":"Why Polkadot?"},{"location":"asset-hub/","text":"Asset Hub Integration Asset Hub is a system chain of Rococo test network which allows for minting and managing fungible and non-fungible assets. Asset Hub Channel Setup Through this PR , the bi-directional HRMP channel setup with Asset Hub became permissionless and can be done through an XCM call from the parachain to Rococo relaychain. Here is the sudo XCM call used by the educhain for reference 0x0f001f000301000314000400000000070010a5d4e81300000000070010a5d4e80006000300c16678419c183c0ae8030000140d01000001003145 . Foreign Asset Registry The native token of a parachain can be registered as a Foriegn Asset on Asset Hub. This can be accomplished through an XCM call from the parachain to the Asset Hub that invokes create call of the foreignAssets pallet. Here is the call that needed to be executed on the Asset Hub to register its native token as a foreign asset 0x3500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000 . As this call cannot be directly executed on Rococo Asset Hub, it is wrapped in a sudo XCM call from the educhain 0x0f001f0003010100a10f0314000400010000070010a5d4e81300010000070010a5d4e80006030248fa7b419ce03500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000140d01000001003145 The next step is to create metadata for the asset on Asset Hub. Here is the call that needed to be executed on the AssetHub via the XCM message from Educhain 0x3511010100314520456475636861696e0c4544550a and here is the sudo XCM call used by the educhain to embed that call 0x0f001f0003010100a10f0314000400010000070010a5d4e81300010000070010a5d4e800060302389c1c419ce03500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000140d01000001003145","title":"Asset Hub Integration"},{"location":"asset-hub/#asset-hub-integration","text":"Asset Hub is a system chain of Rococo test network which allows for minting and managing fungible and non-fungible assets.","title":"Asset Hub Integration"},{"location":"asset-hub/#asset-hub-channel-setup","text":"Through this PR , the bi-directional HRMP channel setup with Asset Hub became permissionless and can be done through an XCM call from the parachain to Rococo relaychain. Here is the sudo XCM call used by the educhain for reference 0x0f001f000301000314000400000000070010a5d4e81300000000070010a5d4e80006000300c16678419c183c0ae8030000140d01000001003145 .","title":"Asset Hub Channel Setup"},{"location":"asset-hub/#foreign-asset-registry","text":"The native token of a parachain can be registered as a Foriegn Asset on Asset Hub. This can be accomplished through an XCM call from the parachain to the Asset Hub that invokes create call of the foreignAssets pallet. Here is the call that needed to be executed on the Asset Hub to register its native token as a foreign asset 0x3500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000 . As this call cannot be directly executed on Rococo Asset Hub, it is wrapped in a sudo XCM call from the educhain 0x0f001f0003010100a10f0314000400010000070010a5d4e81300010000070010a5d4e80006030248fa7b419ce03500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000140d01000001003145 The next step is to create metadata for the asset on Asset Hub. Here is the call that needed to be executed on the AssetHub via the XCM message from Educhain 0x3511010100314520456475636861696e0c4544550a and here is the sudo XCM call used by the educhain to embed that call 0x0f001f0003010100a10f0314000400010000070010a5d4e81300010000070010a5d4e800060302389c1c419ce03500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000140d01000001003145","title":"Foreign Asset Registry"},{"location":"collator/","text":"Collator Setup A collator is a type of node that produces blocks for a parachain. These blocks are not finalized; that's the job of the relay chain. As such, collation is not a secure task, a parachain only really needs one honest collator (honest as in, providing the correct information regarding its the state transitions within) to finalize with the relay chain. A collator could also hold the role of an RPC node, which may be fine for testing, but is not ideal for production. Ideally, one would have a set of dedicated collators (often acting as bootnodes), and a set of RPC nodes separately . In production, it is recommended to setup your collators and RPCs on separate machines with proper load balancing and security. However for testing, it is entirely possible to allow for a single collator to also provide RPC capabilities. If you wish to test an IP-only setup, then either Polkadot JS or the Substrate frontend template can be run locally, allowing insecure connections to be accessed. The Collator Selection Pallet Assuming you are using the collator-section pallet (which is the default in most templates, and what EduChain uses), there are two concepts you will see: Candidates - Candidates for collation, which may or may not be selected. A bond is required to participate. Invulnerables - An account that is guaranteed to be participating in block production, bond or not. They will participate round-robin style in accordance to Aura. Both invulnerables and candidates can be added to a running chain. Invulnerables , however, are usually specified in the chain spec as the \"bootnodes\". It is wise to add at least one collator in your chain_spec - and one that you can start easily, that way you can always gurantee a collator that can produce good, honest blocks. Setting up collators in the chain spec If you are using the parachain template, you can immediately add collators into src/node/chain_spec.rs . You may configure: The initial public session key(s). The collator(s) public keys which are used for rewards. As an example, EduChain sets two initial collation and session public keys, allowing the chain to hit the ground running with two collators other than Bob or Alice: // Collator accounts that produce blocks and earn rewards. pub const COLLATOR1: &str = \"0x38a2edbf7cd629e10700376f941122bf6c6a7b705bb70d6eb15359099055015b\"; pub const COLLATOR2: &str = \"0x3090de03bda721f91d4ea242c63c4220832194e63d2c5b61dbcbdd458224350f\"; // The private key of these session keys needs to be inserted into the collator node for it to start // producing blocks. pub const SESSION1: &str = \"0x1e0f4e48f26d802ce3699872c97e2ec7f8476a9b27a5d4307986ce0ddf0d8530\"; pub const SESSION2: &str = \"0x1e673715db64783eadc6ca927e493ded30f2447efff0f6d5d84578e823f86374\"; Running a \"bootnode\" collator To run a bootnode collator, one just needs to make sure that: The collator is synced with the relay chain (a local copy is needed, pruning is highly recommended) The corresponding private key of the session key (for aura) in the chain spec is inserted, either through rpc or through ( polkadot-parachain key insert ) Check out this sample command, which runs a parachain collator using the polkadot-parachain binary: polkadot-parachain --name COLLATOR_NAME \\ --collator \\ --chain plain-parachain-chainspec.json \\ --base-path ./educhain \\ --rpc-cors=all \\ --port 30333 \\ --rpc-port 8844 \\ -- \\ --chain rococo \\ --sync fast-unsafe \\ --blocks-pruning 256 --state-pruning 256 Note that a few of the arguments, such as --name , --chain , --base-path should be substituted with your own collator name, chain spec, and base path accordingly. Once your collator has synced with its respective relay-chain, and as long as you have coretime (either bulk or on-demand) then your collator should be making blocks. systemd and Collators Once you've achieved a stable setup, you can look into automating the launch of your collator upon startup. Here is an example of a service which automatically starts a shell script using systemd on Ubuntu Linux: start.node.sh : polkadot-parachain --name C2_EDU \\ --collator \\ --chain plain-parachain-chainspec.json \\ --base-path ./educhain \\ --rpc-cors=all \\ --port 30333 \\ --rpc-port 8844 \\ -- \\ --chain rococo \\ --sync fast-unsafe \\ --blocks-pruning 256 collator.service : [Unit] Description=Collator for EduChain After=network.target [Service] Type=simple User=root WorkingDirectory=/root ExecStart=/bin/sh start.node.sh Restart=on-failure [Install] WantedBy=multi-user.target This way, now we can manage our elegantly collator with systemctl : systemctl restart collator - Restarts the collator systemctl stop collator - Stops the collator systemctl start collator - Starts the collator systemctl status collator - Retrieves and displays the status of the collator Here is an example of how a functioning collator looks in action, via the status command: root@ubuntu-s-2vcpu-4gb-amd-nyc3-01:~# systemctl status collator \u25cf collator.service - Collator for EduChain Loaded: loaded (/usr/lib/systemd/system/collator.service; disabled; preset: enabled) Active: active (running) since Wed 2024-06-05 18:02:23 UTC; 5 days ago Main PID: 132465 (sh) Tasks: 46 (limit: 4658) Memory: 2.1G (peak: 2.5G) CPU: 8h 23min 34.532s CGroup: /system.slice/collator.service \u251c\u2500132465 /bin/sh start.node.sh \u2514\u2500132466 polkadot-parachain --name C2_EDU --collator --chain plain-parachain-chainspec.json --base-path ./educhain --rpc-cors=all> Jun 10 20:48:00 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:00 [Relaychain] \u267b\ufe0f Reorg on #10834776,0xf566\u2026ab31 to #10834776,0x1> Jun 10 20:48:00 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:00 [Relaychain] \u2728 Imported #10834776 (0x1583\u2026c83f) Jun 10 20:48:05 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:05 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:05 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:05 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834776 (0x1583\u2026c83f),> Jun 10 20:48:06 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:06 [Relaychain] \u2728 Imported #10834777 (0x705d\u202663cb) Jun 10 20:48:10 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:10 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:10 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:10 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834777 (0x705d\u202663cb),> Jun 10 20:48:12 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:12 [Relaychain] \u2728 Imported #10834778 (0x7a52\u202693f6) Jun 10 20:48:15 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:15 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:15 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:15 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834778 (0x7a52\u202693f6),> Setting up SSL and nginx proxy This doesn't aim to be an exhaustive devops guide on nginx. You should have the following already obtained: A domain. nginx installed. A free SSL certificate via Lets Encrypt via certbot . Once that is in place, navigate to your site's nginx config, and go to the server block that with Certbot's SSL settings, and paste the following: location / { proxy_buffers 16 4k; proxy_buffer_size 2k; proxy_pass http://localhost:8844; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } Please note that the URL \"http://localhost:8844\"'s port must match your running collator. server { server_name rpc.web3educhain.xyz www.rpc.web3educhain.xyz; location / { proxy_buffers 16 4k; proxy_buffer_size 2k; proxy_pass http://localhost:8844; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } listen 443 ssl; # managed by Certbot # other SSL info here... } Once this is in place, restart nginx, and you should be able to access the node via port 443 .","title":"Collator Setup"},{"location":"collator/#collator-setup","text":"A collator is a type of node that produces blocks for a parachain. These blocks are not finalized; that's the job of the relay chain. As such, collation is not a secure task, a parachain only really needs one honest collator (honest as in, providing the correct information regarding its the state transitions within) to finalize with the relay chain. A collator could also hold the role of an RPC node, which may be fine for testing, but is not ideal for production. Ideally, one would have a set of dedicated collators (often acting as bootnodes), and a set of RPC nodes separately . In production, it is recommended to setup your collators and RPCs on separate machines with proper load balancing and security. However for testing, it is entirely possible to allow for a single collator to also provide RPC capabilities. If you wish to test an IP-only setup, then either Polkadot JS or the Substrate frontend template can be run locally, allowing insecure connections to be accessed.","title":"Collator Setup"},{"location":"collator/#the-collator-selection-pallet","text":"Assuming you are using the collator-section pallet (which is the default in most templates, and what EduChain uses), there are two concepts you will see: Candidates - Candidates for collation, which may or may not be selected. A bond is required to participate. Invulnerables - An account that is guaranteed to be participating in block production, bond or not. They will participate round-robin style in accordance to Aura. Both invulnerables and candidates can be added to a running chain. Invulnerables , however, are usually specified in the chain spec as the \"bootnodes\". It is wise to add at least one collator in your chain_spec - and one that you can start easily, that way you can always gurantee a collator that can produce good, honest blocks.","title":"The Collator Selection Pallet"},{"location":"collator/#setting-up-collators-in-the-chain-spec","text":"If you are using the parachain template, you can immediately add collators into src/node/chain_spec.rs . You may configure: The initial public session key(s). The collator(s) public keys which are used for rewards. As an example, EduChain sets two initial collation and session public keys, allowing the chain to hit the ground running with two collators other than Bob or Alice: // Collator accounts that produce blocks and earn rewards. pub const COLLATOR1: &str = \"0x38a2edbf7cd629e10700376f941122bf6c6a7b705bb70d6eb15359099055015b\"; pub const COLLATOR2: &str = \"0x3090de03bda721f91d4ea242c63c4220832194e63d2c5b61dbcbdd458224350f\"; // The private key of these session keys needs to be inserted into the collator node for it to start // producing blocks. pub const SESSION1: &str = \"0x1e0f4e48f26d802ce3699872c97e2ec7f8476a9b27a5d4307986ce0ddf0d8530\"; pub const SESSION2: &str = \"0x1e673715db64783eadc6ca927e493ded30f2447efff0f6d5d84578e823f86374\";","title":"Setting up collators in the chain spec"},{"location":"collator/#running-a-bootnode-collator","text":"To run a bootnode collator, one just needs to make sure that: The collator is synced with the relay chain (a local copy is needed, pruning is highly recommended) The corresponding private key of the session key (for aura) in the chain spec is inserted, either through rpc or through ( polkadot-parachain key insert ) Check out this sample command, which runs a parachain collator using the polkadot-parachain binary: polkadot-parachain --name COLLATOR_NAME \\ --collator \\ --chain plain-parachain-chainspec.json \\ --base-path ./educhain \\ --rpc-cors=all \\ --port 30333 \\ --rpc-port 8844 \\ -- \\ --chain rococo \\ --sync fast-unsafe \\ --blocks-pruning 256 --state-pruning 256 Note that a few of the arguments, such as --name , --chain , --base-path should be substituted with your own collator name, chain spec, and base path accordingly. Once your collator has synced with its respective relay-chain, and as long as you have coretime (either bulk or on-demand) then your collator should be making blocks.","title":"Running a \"bootnode\" collator"},{"location":"collator/#systemd-and-collators","text":"Once you've achieved a stable setup, you can look into automating the launch of your collator upon startup. Here is an example of a service which automatically starts a shell script using systemd on Ubuntu Linux: start.node.sh : polkadot-parachain --name C2_EDU \\ --collator \\ --chain plain-parachain-chainspec.json \\ --base-path ./educhain \\ --rpc-cors=all \\ --port 30333 \\ --rpc-port 8844 \\ -- \\ --chain rococo \\ --sync fast-unsafe \\ --blocks-pruning 256 collator.service : [Unit] Description=Collator for EduChain After=network.target [Service] Type=simple User=root WorkingDirectory=/root ExecStart=/bin/sh start.node.sh Restart=on-failure [Install] WantedBy=multi-user.target This way, now we can manage our elegantly collator with systemctl : systemctl restart collator - Restarts the collator systemctl stop collator - Stops the collator systemctl start collator - Starts the collator systemctl status collator - Retrieves and displays the status of the collator Here is an example of how a functioning collator looks in action, via the status command: root@ubuntu-s-2vcpu-4gb-amd-nyc3-01:~# systemctl status collator \u25cf collator.service - Collator for EduChain Loaded: loaded (/usr/lib/systemd/system/collator.service; disabled; preset: enabled) Active: active (running) since Wed 2024-06-05 18:02:23 UTC; 5 days ago Main PID: 132465 (sh) Tasks: 46 (limit: 4658) Memory: 2.1G (peak: 2.5G) CPU: 8h 23min 34.532s CGroup: /system.slice/collator.service \u251c\u2500132465 /bin/sh start.node.sh \u2514\u2500132466 polkadot-parachain --name C2_EDU --collator --chain plain-parachain-chainspec.json --base-path ./educhain --rpc-cors=all> Jun 10 20:48:00 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:00 [Relaychain] \u267b\ufe0f Reorg on #10834776,0xf566\u2026ab31 to #10834776,0x1> Jun 10 20:48:00 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:00 [Relaychain] \u2728 Imported #10834776 (0x1583\u2026c83f) Jun 10 20:48:05 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:05 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:05 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:05 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834776 (0x1583\u2026c83f),> Jun 10 20:48:06 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:06 [Relaychain] \u2728 Imported #10834777 (0x705d\u202663cb) Jun 10 20:48:10 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:10 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:10 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:10 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834777 (0x705d\u202663cb),> Jun 10 20:48:12 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:12 [Relaychain] \u2728 Imported #10834778 (0x7a52\u202693f6) Jun 10 20:48:15 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:15 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:15 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:15 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834778 (0x7a52\u202693f6),>","title":"systemd and Collators"},{"location":"collator/#setting-up-ssl-and-nginx-proxy","text":"This doesn't aim to be an exhaustive devops guide on nginx. You should have the following already obtained: A domain. nginx installed. A free SSL certificate via Lets Encrypt via certbot . Once that is in place, navigate to your site's nginx config, and go to the server block that with Certbot's SSL settings, and paste the following: location / { proxy_buffers 16 4k; proxy_buffer_size 2k; proxy_pass http://localhost:8844; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } Please note that the URL \"http://localhost:8844\"'s port must match your running collator. server { server_name rpc.web3educhain.xyz www.rpc.web3educhain.xyz; location / { proxy_buffers 16 4k; proxy_buffer_size 2k; proxy_pass http://localhost:8844; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } listen 443 ssl; # managed by Certbot # other SSL info here... } Once this is in place, restart nginx, and you should be able to access the node via port 443 .","title":"Setting up SSL and nginx proxy"},{"location":"launch/","text":"Launching on Rococo OpenZepppelin Polkadot Generic Runtime Template was chosen as a candidate for launching Educhain. They crafted the pallet list to be as minimalistic and preserved important pallets that are used in the Polkadot ecosystem. Their docs serve as a good starting point to understand the launch process of a parachain on Polkadot testnet Rococo. Personalize Template In a single shot, you can (almost) rebrand the runtime template to your own project by replacing the occurrences of parachain-runtime and parachain_runtime with your project name. Set Genesis Config It is common that most of the tutorials and templates use Alice or Bob keys for the root account, and for collator's keys and session keys. It is obvious that these should be replaced by custom keys. It is recommended that you use an account created on a cold wallet for the root account. It is also important for the collator key and its session key to be different. The collator key is recommended to be created on a cold wallet and the session key can be generated from a hot wallet, as you need to enter its seed/private key into the collator's key store to start producing blocks. The session keys are rotated often for this reason. Collator Node Setup You can spin up a collator on your local machine or on a cloud instance of your choice. Educhain node runs as a Digital Ocean droplet . If you like to interact with your collator through the Polkadot JS UI , the connection needs to be secured via SSL. This requires securing a domain (such as web3educhain.xyz) and then setting up SSL to access your Droplet (or other VPS) for the RPC address to be able to interact with it using Polkadot JS UI. Securing via SSL requires a proxy setup for the RPC interfaces of your node. See the collator section of this wiki to learn more about launching collators. Block Production Educhain is deployed on Rococo as an on-demand parachain. Transactions can be submitted to the collator node and they enter the transaction pool. When you like to execute these transactions, an order can be placed on Rococo relay chain for the parachain block production and validation through onDemandAssignmentProvider pallet call. If you intend to have a parachain that produces blocks continously, you can purchase bulk coretime through awesome interfaces from Lastic or RegionX . For more details and tips on ordering coretime, see the ordering coretime page .","title":"Launching on Rococo"},{"location":"launch/#launching-on-rococo","text":"OpenZepppelin Polkadot Generic Runtime Template was chosen as a candidate for launching Educhain. They crafted the pallet list to be as minimalistic and preserved important pallets that are used in the Polkadot ecosystem. Their docs serve as a good starting point to understand the launch process of a parachain on Polkadot testnet Rococo.","title":"Launching on Rococo"},{"location":"launch/#personalize-template","text":"In a single shot, you can (almost) rebrand the runtime template to your own project by replacing the occurrences of parachain-runtime and parachain_runtime with your project name.","title":"Personalize Template"},{"location":"launch/#set-genesis-config","text":"It is common that most of the tutorials and templates use Alice or Bob keys for the root account, and for collator's keys and session keys. It is obvious that these should be replaced by custom keys. It is recommended that you use an account created on a cold wallet for the root account. It is also important for the collator key and its session key to be different. The collator key is recommended to be created on a cold wallet and the session key can be generated from a hot wallet, as you need to enter its seed/private key into the collator's key store to start producing blocks. The session keys are rotated often for this reason.","title":"Set Genesis Config"},{"location":"launch/#collator-node-setup","text":"You can spin up a collator on your local machine or on a cloud instance of your choice. Educhain node runs as a Digital Ocean droplet . If you like to interact with your collator through the Polkadot JS UI , the connection needs to be secured via SSL. This requires securing a domain (such as web3educhain.xyz) and then setting up SSL to access your Droplet (or other VPS) for the RPC address to be able to interact with it using Polkadot JS UI. Securing via SSL requires a proxy setup for the RPC interfaces of your node. See the collator section of this wiki to learn more about launching collators.","title":"Collator Node Setup"},{"location":"launch/#block-production","text":"Educhain is deployed on Rococo as an on-demand parachain. Transactions can be submitted to the collator node and they enter the transaction pool. When you like to execute these transactions, an order can be placed on Rococo relay chain for the parachain block production and validation through onDemandAssignmentProvider pallet call. If you intend to have a parachain that produces blocks continously, you can purchase bulk coretime through awesome interfaces from Lastic or RegionX . For more details and tips on ordering coretime, see the ordering coretime page .","title":"Block Production"},{"location":"ordering-coretime/","text":"Ordering Coretime There are two types of coretime: Bulk coretime On-demand coretime Ordering on-demand coretime Ordering via CLI polkadot-js-api tx.onDemandAssignmentProvider.placeOrderAllowDeath \\ 1000000000000 \\ 4428 \\ --seed \"your seed here\" \\ --ws \"wss://rococo-rpc.polkadot.io\" Ordering via PolkadotJS Use the following guides to order on-demand coretime through PolkadotJS. Ordering Bulk Coretime Use the following guides to order bulk coretime.","title":"Ordering Coretime"},{"location":"ordering-coretime/#ordering-coretime","text":"There are two types of coretime: Bulk coretime On-demand coretime","title":"Ordering Coretime"},{"location":"ordering-coretime/#ordering-on-demand-coretime","text":"","title":"Ordering on-demand coretime"},{"location":"ordering-coretime/#ordering-via-cli","text":"polkadot-js-api tx.onDemandAssignmentProvider.placeOrderAllowDeath \\ 1000000000000 \\ 4428 \\ --seed \"your seed here\" \\ --ws \"wss://rococo-rpc.polkadot.io\"","title":"Ordering via CLI"},{"location":"ordering-coretime/#ordering-via-polkadotjs","text":"Use the following guides to order on-demand coretime through PolkadotJS.","title":"Ordering via PolkadotJS"},{"location":"ordering-coretime/#ordering-bulk-coretime","text":"Use the following guides to order bulk coretime.","title":"Ordering Bulk Coretime"}]}