{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web3 Educhain Educating Web3 through Polkadot SDK. . Check out the EduChain on PolkadotJS here Why Educhain? When creating the Web3 Educhain project, there were around 50 parachains on the Polkadot network but no concrete guides on launching and maintaining a production-grade parachain. There are also very limited tutorials that demonstrate the Polkadot SDK features that are shipped with FRAME library. Web3 Educhain intends to address these issues by providing a realtime, running example with documentation on how to replicate what achieve here. Why Polkadot? Along with the efficient utility of coretime and blockspace, a parachain deployed on Polkadot has access to Multi-billion dollar crypto-economic security backed finality from block number one. Secure interoperability with multiple chains within and outside of the Polkadot ecosystem. Customizable blockchain runtimes written in Rust and executed as Wasm code. Decentralized network and networking stack with light-client prioritized design. Visionary, intellectual, smart (and at times oversmart) developer community. Polkadot OpenGov and its Treasury, which pays OECD grade salaries to the Technical Fellowship and funds numerous development initiatives through bounties. With Agile Coretime, parachains can now produce blocks continuously or on demand. By activating Async Backing, parachains can produce blocks every 6 seconds whose transactions get finalized in 20-60 seconds, and around 800 TPS . With elastic scaling , the throughput of parachains is expected to improve further, with multiple cores being utilized at the same time. In the near future, parachains can subscribe to the parachains service of the JAM chain , which enables advanced features that makes blockchain technology feasible for the majority of its use cases. Launch a Parachain With the available templates, you can now launch a production-grade blockchain in a day! To learn how, navigate to the next page.","title":"Web3 Educhain"},{"location":"#web3-educhain","text":"Educating Web3 through Polkadot SDK. . Check out the EduChain on PolkadotJS here","title":"Web3 Educhain"},{"location":"#why-educhain","text":"When creating the Web3 Educhain project, there were around 50 parachains on the Polkadot network but no concrete guides on launching and maintaining a production-grade parachain. There are also very limited tutorials that demonstrate the Polkadot SDK features that are shipped with FRAME library. Web3 Educhain intends to address these issues by providing a realtime, running example with documentation on how to replicate what achieve here.","title":"Why Educhain?"},{"location":"#why-polkadot","text":"Along with the efficient utility of coretime and blockspace, a parachain deployed on Polkadot has access to Multi-billion dollar crypto-economic security backed finality from block number one. Secure interoperability with multiple chains within and outside of the Polkadot ecosystem. Customizable blockchain runtimes written in Rust and executed as Wasm code. Decentralized network and networking stack with light-client prioritized design. Visionary, intellectual, smart (and at times oversmart) developer community. Polkadot OpenGov and its Treasury, which pays OECD grade salaries to the Technical Fellowship and funds numerous development initiatives through bounties. With Agile Coretime, parachains can now produce blocks continuously or on demand. By activating Async Backing, parachains can produce blocks every 6 seconds whose transactions get finalized in 20-60 seconds, and around 800 TPS . With elastic scaling , the throughput of parachains is expected to improve further, with multiple cores being utilized at the same time. In the near future, parachains can subscribe to the parachains service of the JAM chain , which enables advanced features that makes blockchain technology feasible for the majority of its use cases.","title":"Why Polkadot?"},{"location":"#launch-a-parachain","text":"With the available templates, you can now launch a production-grade blockchain in a day! To learn how, navigate to the next page.","title":"Launch a Parachain"},{"location":"asset-hub/","text":"Asset Hub Integration Asset Hub is a system chain of Rococo test network which allows for minting and managing fungible and non-fungible assets. Asset Hub Channel Setup Through this PR , the bi-directional HRMP channel setup with Asset Hub became permissionless and can be done through an XCM call from the parachain to Rococo relaychain. Here is the sudo XCM call used by the educhain for reference 0x0f001f000301000314000400000000070010a5d4e81300000000070010a5d4e80006000300c16678419c183c0ae8030000140d01000001003145 . Foreign Asset Registry The native token of a parachain can be registered as a Foriegn Asset on Asset Hub. This can be accomplished through an XCM call from the parachain to the Asset Hub that invokes create call of the foreignAssets pallet. Here is the call that needed to be executed on the Asset Hub to register its native token as a foreign asset 0x3500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000 . As this call cannot be directly executed on Rococo Asset Hub, it is wrapped in a sudo XCM call from the educhain 0x0f001f0003010100a10f0314000400010000070010a5d4e81300010000070010a5d4e80006030248fa7b419ce03500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000140d01000001003145 The next step is to create metadata for the asset on Asset Hub. Here is the call that needed to be executed on the AssetHub via the XCM message from Educhain 0x3511010100314520456475636861696e0c4544550a and here is the sudo XCM call used by the educhain to embed that call 0x0f001f0003010100a10f0314000400010000070010a5d4e81300010000070010a5d4e800060302389c1c419ce03500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000140d01000001003145","title":"Asset Hub Integration"},{"location":"asset-hub/#asset-hub-integration","text":"Asset Hub is a system chain of Rococo test network which allows for minting and managing fungible and non-fungible assets.","title":"Asset Hub Integration"},{"location":"asset-hub/#asset-hub-channel-setup","text":"Through this PR , the bi-directional HRMP channel setup with Asset Hub became permissionless and can be done through an XCM call from the parachain to Rococo relaychain. Here is the sudo XCM call used by the educhain for reference 0x0f001f000301000314000400000000070010a5d4e81300000000070010a5d4e80006000300c16678419c183c0ae8030000140d01000001003145 .","title":"Asset Hub Channel Setup"},{"location":"asset-hub/#foreign-asset-registry","text":"The native token of a parachain can be registered as a Foriegn Asset on Asset Hub. This can be accomplished through an XCM call from the parachain to the Asset Hub that invokes create call of the foreignAssets pallet. Here is the call that needed to be executed on the Asset Hub to register its native token as a foreign asset 0x3500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000 . As this call cannot be directly executed on Rococo Asset Hub, it is wrapped in a sudo XCM call from the educhain 0x0f001f0003010100a10f0314000400010000070010a5d4e81300010000070010a5d4e80006030248fa7b419ce03500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000140d01000001003145 The next step is to create metadata for the asset on Asset Hub. Here is the call that needed to be executed on the AssetHub via the XCM message from Educhain 0x3511010100314520456475636861696e0c4544550a and here is the sudo XCM call used by the educhain to embed that call 0x0f001f0003010100a10f0314000400010000070010a5d4e81300010000070010a5d4e800060302389c1c419ce03500010100314500706172614c11000000000000000000000000000000000000000000000000000000ca9a3b000000000000000000000000140d01000001003145","title":"Foreign Asset Registry"},{"location":"collator/","text":"Collator Setup A collator is a type of node that produces blocks for a parachain. These blocks are not finalized; that's the job of the relay chain. As such, collation is not a secure task, a parachain only really needs one honest collator (honest as in, providing the correct information regarding its the state transitions within) to finalize with the relay chain. A collator could also hold the role of an RPC node, which may be fine for testing, but is not ideal for production. Ideally, one would have a set of dedicated collators (often acting as bootnodes), and a set of RPC nodes separately . In production, it is recommended to set up your collators and RPCs on separate machines with proper load balancing and security. For testing, it is entirely possible to allow for a single collator to also provide RPC capabilities. If you wish to test an IP-only setup, then either Polkadot JS or the Substrate frontend template can be run locally, allowing insecure connections to be accessed. The Collator Selection Pallet Assuming you are using the collator-section pallet (which is the default in most templates, and what EduChain uses), there are two concepts you will see: Candidates - Candidates for collation, which may or may not be selected. A bond is required to participate. Invulnerables - An account that is guaranteed to be participating in block production, bond or not. They will participate round-robin style in accordance to Aura. Both invulnerables and candidates can be added to a running chain. Invulnerables , however, are usually specified in the chain spec as the \"bootnodes\". It is wise to add at least one collator in your chain_spec - and one that you can start easily, that way you can always gurantee a collator that can produce good, honest blocks. Setting up collators in the chain spec If you are using the parachain template, you can immediately add collators into src/node/chain_spec.rs . You may configure: The initial public session key(s). The collator(s) public keys which are used for rewards. As an example, EduChain sets two initial collation and session public keys, allowing the chain to hit the ground running with two collators other than Bob or Alice: // Collator accounts that produce blocks and earn rewards. pub const COLLATOR1: &str = \"0x38a2edbf7cd629e10700376f941122bf6c6a7b705bb70d6eb15359099055015b\"; pub const COLLATOR2: &str = \"0x3090de03bda721f91d4ea242c63c4220832194e63d2c5b61dbcbdd458224350f\"; // The private key of these session keys needs to be inserted into the collator node for it to start // producing blocks. pub const SESSION1: &str = \"0x1e0f4e48f26d802ce3699872c97e2ec7f8476a9b27a5d4307986ce0ddf0d8530\"; pub const SESSION2: &str = \"0x1e673715db64783eadc6ca927e493ded30f2447efff0f6d5d84578e823f86374\"; Running a \"bootnode\" collator To run a bootnode collator, one just needs to make sure that: The collator is synced with the relay chain (a local copy is needed, pruning is highly recommended) The corresponding private key of the session key (for aura) in the chain spec is inserted, either through rpc or through ( polkadot-parachain key insert ) Check out this sample command, which runs a parachain collator using the polkadot-parachain binary: polkadot-parachain --name COLLATOR_NAME \\ --collator \\ --chain plain-parachain-chainspec.json \\ --base-path ./educhain \\ --rpc-cors=all \\ --port 30333 \\ --rpc-port 8844 \\ -- \\ --chain rococo \\ --sync fast-unsafe \\ --blocks-pruning 256 --state-pruning 256 Note that a few of the arguments, such as --name , --chain , --base-path should be substituted with your own collator name, chain spec, and base path accordingly. Once your collator has synced with its respective relay-chain, and as long as you have coretime (either bulk or on-demand) then your collator should be making blocks. systemd and Collators Once you've achieved a stable setup, you can look into automating the launch of your collator upon startup. Here is an example of a service which automatically starts a shell script using systemd on Ubuntu Linux: start.node.sh : polkadot-parachain --name C2_EDU \\ --collator \\ --chain plain-parachain-chainspec.json \\ --base-path ./educhain \\ --rpc-cors=all \\ --port 30333 \\ --rpc-port 8844 \\ -- \\ --chain rococo \\ --sync fast-unsafe \\ --blocks-pruning 256 collator.service : [Unit] Description=Collator for EduChain After=network.target [Service] Type=simple User=root WorkingDirectory=/root ExecStart=/bin/sh start.node.sh Restart=on-failure [Install] WantedBy=multi-user.target This way, now we can manage our elegantly collator with systemctl : systemctl restart collator - Restarts the collator systemctl stop collator - Stops the collator systemctl start collator - Starts the collator systemctl status collator - Retrieves and displays the status of the collator Here is an example of how a functioning collator looks in action, via the status command: root@ubuntu-s-2vcpu-4gb-amd-nyc3-01:~# systemctl status collator \u25cf collator.service - Collator for EduChain Loaded: loaded (/usr/lib/systemd/system/collator.service; disabled; preset: enabled) Active: active (running) since Wed 2024-06-05 18:02:23 UTC; 5 days ago Main PID: 132465 (sh) Tasks: 46 (limit: 4658) Memory: 2.1G (peak: 2.5G) CPU: 8h 23min 34.532s CGroup: /system.slice/collator.service \u251c\u2500132465 /bin/sh start.node.sh \u2514\u2500132466 polkadot-parachain --name C2_EDU --collator --chain plain-parachain-chainspec.json --base-path ./educhain --rpc-cors=all> Jun 10 20:48:00 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:00 [Relaychain] \u267b\ufe0f Reorg on #10834776,0xf566\u2026ab31 to #10834776,0x1> Jun 10 20:48:00 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:00 [Relaychain] \u2728 Imported #10834776 (0x1583\u2026c83f) Jun 10 20:48:05 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:05 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:05 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:05 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834776 (0x1583\u2026c83f),> Jun 10 20:48:06 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:06 [Relaychain] \u2728 Imported #10834777 (0x705d\u202663cb) Jun 10 20:48:10 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:10 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:10 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:10 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834777 (0x705d\u202663cb),> Jun 10 20:48:12 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:12 [Relaychain] \u2728 Imported #10834778 (0x7a52\u202693f6) Jun 10 20:48:15 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:15 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:15 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:15 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834778 (0x7a52\u202693f6),> Setting up SSL and nginx proxy This doesn't aim to be an exhaustive devops guide on nginx. You should have the following already obtained: A domain. nginx installed. A free SSL certificate via Lets Encrypt via certbot . Once that is in place, navigate to your site's nginx config, and go to the server block that with Certbot's SSL settings, and paste the following: location / { proxy_buffers 16 4k; proxy_buffer_size 2k; proxy_pass http://localhost:8844; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } Please note that the URL \"http://localhost:8844\"'s port must match your running collator. server { server_name rpc.web3educhain.xyz www.rpc.web3educhain.xyz; location / { proxy_buffers 16 4k; proxy_buffer_size 2k; proxy_pass http://localhost:8844; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } listen 443 ssl; # managed by Certbot # other SSL info here... } Once this is in place, restart nginx, and you should be able to access the node via port 443 .","title":"Collator Setup"},{"location":"collator/#collator-setup","text":"A collator is a type of node that produces blocks for a parachain. These blocks are not finalized; that's the job of the relay chain. As such, collation is not a secure task, a parachain only really needs one honest collator (honest as in, providing the correct information regarding its the state transitions within) to finalize with the relay chain. A collator could also hold the role of an RPC node, which may be fine for testing, but is not ideal for production. Ideally, one would have a set of dedicated collators (often acting as bootnodes), and a set of RPC nodes separately . In production, it is recommended to set up your collators and RPCs on separate machines with proper load balancing and security. For testing, it is entirely possible to allow for a single collator to also provide RPC capabilities. If you wish to test an IP-only setup, then either Polkadot JS or the Substrate frontend template can be run locally, allowing insecure connections to be accessed.","title":"Collator Setup"},{"location":"collator/#the-collator-selection-pallet","text":"Assuming you are using the collator-section pallet (which is the default in most templates, and what EduChain uses), there are two concepts you will see: Candidates - Candidates for collation, which may or may not be selected. A bond is required to participate. Invulnerables - An account that is guaranteed to be participating in block production, bond or not. They will participate round-robin style in accordance to Aura. Both invulnerables and candidates can be added to a running chain. Invulnerables , however, are usually specified in the chain spec as the \"bootnodes\". It is wise to add at least one collator in your chain_spec - and one that you can start easily, that way you can always gurantee a collator that can produce good, honest blocks.","title":"The Collator Selection Pallet"},{"location":"collator/#setting-up-collators-in-the-chain-spec","text":"If you are using the parachain template, you can immediately add collators into src/node/chain_spec.rs . You may configure: The initial public session key(s). The collator(s) public keys which are used for rewards. As an example, EduChain sets two initial collation and session public keys, allowing the chain to hit the ground running with two collators other than Bob or Alice: // Collator accounts that produce blocks and earn rewards. pub const COLLATOR1: &str = \"0x38a2edbf7cd629e10700376f941122bf6c6a7b705bb70d6eb15359099055015b\"; pub const COLLATOR2: &str = \"0x3090de03bda721f91d4ea242c63c4220832194e63d2c5b61dbcbdd458224350f\"; // The private key of these session keys needs to be inserted into the collator node for it to start // producing blocks. pub const SESSION1: &str = \"0x1e0f4e48f26d802ce3699872c97e2ec7f8476a9b27a5d4307986ce0ddf0d8530\"; pub const SESSION2: &str = \"0x1e673715db64783eadc6ca927e493ded30f2447efff0f6d5d84578e823f86374\";","title":"Setting up collators in the chain spec"},{"location":"collator/#running-a-bootnode-collator","text":"To run a bootnode collator, one just needs to make sure that: The collator is synced with the relay chain (a local copy is needed, pruning is highly recommended) The corresponding private key of the session key (for aura) in the chain spec is inserted, either through rpc or through ( polkadot-parachain key insert ) Check out this sample command, which runs a parachain collator using the polkadot-parachain binary: polkadot-parachain --name COLLATOR_NAME \\ --collator \\ --chain plain-parachain-chainspec.json \\ --base-path ./educhain \\ --rpc-cors=all \\ --port 30333 \\ --rpc-port 8844 \\ -- \\ --chain rococo \\ --sync fast-unsafe \\ --blocks-pruning 256 --state-pruning 256 Note that a few of the arguments, such as --name , --chain , --base-path should be substituted with your own collator name, chain spec, and base path accordingly. Once your collator has synced with its respective relay-chain, and as long as you have coretime (either bulk or on-demand) then your collator should be making blocks.","title":"Running a \"bootnode\" collator"},{"location":"collator/#systemd-and-collators","text":"Once you've achieved a stable setup, you can look into automating the launch of your collator upon startup. Here is an example of a service which automatically starts a shell script using systemd on Ubuntu Linux: start.node.sh : polkadot-parachain --name C2_EDU \\ --collator \\ --chain plain-parachain-chainspec.json \\ --base-path ./educhain \\ --rpc-cors=all \\ --port 30333 \\ --rpc-port 8844 \\ -- \\ --chain rococo \\ --sync fast-unsafe \\ --blocks-pruning 256 collator.service : [Unit] Description=Collator for EduChain After=network.target [Service] Type=simple User=root WorkingDirectory=/root ExecStart=/bin/sh start.node.sh Restart=on-failure [Install] WantedBy=multi-user.target This way, now we can manage our elegantly collator with systemctl : systemctl restart collator - Restarts the collator systemctl stop collator - Stops the collator systemctl start collator - Starts the collator systemctl status collator - Retrieves and displays the status of the collator Here is an example of how a functioning collator looks in action, via the status command: root@ubuntu-s-2vcpu-4gb-amd-nyc3-01:~# systemctl status collator \u25cf collator.service - Collator for EduChain Loaded: loaded (/usr/lib/systemd/system/collator.service; disabled; preset: enabled) Active: active (running) since Wed 2024-06-05 18:02:23 UTC; 5 days ago Main PID: 132465 (sh) Tasks: 46 (limit: 4658) Memory: 2.1G (peak: 2.5G) CPU: 8h 23min 34.532s CGroup: /system.slice/collator.service \u251c\u2500132465 /bin/sh start.node.sh \u2514\u2500132466 polkadot-parachain --name C2_EDU --collator --chain plain-parachain-chainspec.json --base-path ./educhain --rpc-cors=all> Jun 10 20:48:00 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:00 [Relaychain] \u267b\ufe0f Reorg on #10834776,0xf566\u2026ab31 to #10834776,0x1> Jun 10 20:48:00 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:00 [Relaychain] \u2728 Imported #10834776 (0x1583\u2026c83f) Jun 10 20:48:05 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:05 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:05 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:05 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834776 (0x1583\u2026c83f),> Jun 10 20:48:06 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:06 [Relaychain] \u2728 Imported #10834777 (0x705d\u202663cb) Jun 10 20:48:10 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:10 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:10 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:10 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834777 (0x705d\u202663cb),> Jun 10 20:48:12 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:12 [Relaychain] \u2728 Imported #10834778 (0x7a52\u202693f6) Jun 10 20:48:15 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:15 [Parachain] \ud83d\udca4 Idle (0 peers), best: #153 (0x998c\u2026e0d8), finali> Jun 10 20:48:15 ubuntu-s-2vcpu-4gb-amd-nyc3-01 sh[132466]: 2024-06-10 20:48:15 [Relaychain] \ud83d\udca4 Idle (15 peers), best: #10834778 (0x7a52\u202693f6),>","title":"systemd and Collators"},{"location":"collator/#setting-up-ssl-and-nginx-proxy","text":"This doesn't aim to be an exhaustive devops guide on nginx. You should have the following already obtained: A domain. nginx installed. A free SSL certificate via Lets Encrypt via certbot . Once that is in place, navigate to your site's nginx config, and go to the server block that with Certbot's SSL settings, and paste the following: location / { proxy_buffers 16 4k; proxy_buffer_size 2k; proxy_pass http://localhost:8844; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } Please note that the URL \"http://localhost:8844\"'s port must match your running collator. server { server_name rpc.web3educhain.xyz www.rpc.web3educhain.xyz; location / { proxy_buffers 16 4k; proxy_buffer_size 2k; proxy_pass http://localhost:8844; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } listen 443 ssl; # managed by Certbot # other SSL info here... } Once this is in place, restart nginx, and you should be able to access the node via port 443 .","title":"Setting up SSL and nginx proxy"},{"location":"install/","text":"Dependencies The Wiki details how to install the necessary prerequisites , including Rust and its tooling. You will need cargo , amongst other dependencies, before progressing. The \"Omninode\" The polkadot-parachain can be used a universal collator instance for running a parachain (an \"omninode\"), and can be installed follows: cargo install --git https://github.com/paritytech/polkadot-sdk --tag polkadot-v1.10.0 --force polkadot-parachain-bin You can change --tag to the specific release of your choice. Which will allow you to run the polkadot-parachain : \u276f polkadot-parachain --version polkadot-parachain 1.10.0-7049c3c9883 # or, which ever release you cloned. Chain Spec Builder The chain-spec-builder tool is used for building a chain specification from a Wasm binary. It can be installed as follows: cargo install staging-chain-spec-builder And can be used as follows: \u276f chain-spec-builder --help A utility to easily create a chain spec definition Usage: chain-spec-builder [OPTIONS] <COMMAND> Commands: create Create a new chain spec by interacting with the provided runtime wasm blob verify Verifies the provided input chain spec update-code Updates the code in the provided input chain spec convert-to-raw Converts the given chain spec into the raw format list-presets Lists available presets display-preset Displays given preset help Print this message or the help of the given subcommand(s) Options: -c, --chain-spec-path <CHAIN_SPEC_PATH> The path where the chain spec should be saved [default: ./chain_spec.json] -h, --help Print help","title":"Dependencies"},{"location":"install/#dependencies","text":"The Wiki details how to install the necessary prerequisites , including Rust and its tooling. You will need cargo , amongst other dependencies, before progressing.","title":"Dependencies"},{"location":"install/#the-omninode","text":"The polkadot-parachain can be used a universal collator instance for running a parachain (an \"omninode\"), and can be installed follows: cargo install --git https://github.com/paritytech/polkadot-sdk --tag polkadot-v1.10.0 --force polkadot-parachain-bin You can change --tag to the specific release of your choice. Which will allow you to run the polkadot-parachain : \u276f polkadot-parachain --version polkadot-parachain 1.10.0-7049c3c9883 # or, which ever release you cloned.","title":"The \"Omninode\""},{"location":"install/#chain-spec-builder","text":"The chain-spec-builder tool is used for building a chain specification from a Wasm binary. It can be installed as follows: cargo install staging-chain-spec-builder And can be used as follows: \u276f chain-spec-builder --help A utility to easily create a chain spec definition Usage: chain-spec-builder [OPTIONS] <COMMAND> Commands: create Create a new chain spec by interacting with the provided runtime wasm blob verify Verifies the provided input chain spec update-code Updates the code in the provided input chain spec convert-to-raw Converts the given chain spec into the raw format list-presets Lists available presets display-preset Displays given preset help Print this message or the help of the given subcommand(s) Options: -c, --chain-spec-path <CHAIN_SPEC_PATH> The path where the chain spec should be saved [default: ./chain_spec.json] -h, --help Print help","title":"Chain Spec Builder"},{"location":"launch/","text":"Launching on Rococo OpenZepppelin Polkadot Generic Runtime Template was chosen as a candidate for launching Educhain. They crafted the pallet list to be as minimalistic and preserved important pallets that are used in the Polkadot ecosystem. Their docs serve as a good starting point to understand the launch process of a parachain on Polkadot testnet Rococo. Personalize Template In a single shot, you can (almost) rebrand the runtime template to your own project by replacing the occurrences of parachain-runtime and parachain_runtime with your project name. You may also add, remove, or create new pallets and add them to the runtime. Adding new pallets involves correctly configuring their associated types and ensuring they are a part of the construct_runtime! macro. You can view more about h ow pallets work in the Polkadot SDK docs. Set Genesis Config It is common that most of the tutorials and templates use Alice or Bob keys for the root, collator and session keys. It is obvious that these should be replaced by custom keys. It is recommended that you use an account created on a cold wallet for the root account. It is also important for the collator key and its session key to be different. The collator key is recommended to be created on a cold wallet and the session key can be generated from a hot wallet, as you need to enter its seed/private key into the collator's key store to start producing blocks. The session keys are rotated often for this reason. The genesis config can be used to also configure the initial state of your pallets. For more information on the genesis config, see these Polkadot SDK docs. For generating a chain spec, you can either view our process here or refer to the corresponding Polkadot SDK docs. Collator Node Setup You can spin up a collator on your local machine or on a cloud instance of your choice. Educhain node runs as a Digital Ocean droplet . If you like to interact with your collator through the Polkadot JS UI , the connection needs to be secured via SSL. This requires securing a domain (such as web3educhain.xyz) and then setting up SSL to access your Droplet (or other VPS) for the RPC address to be able to interact with it using Polkadot JS UI. Securing via SSL requires a proxy setup for the RPC interfaces of your node. See the collator section of this wiki to learn more about launching collators. Block Production Educhain is deployed on Rococo as an on-demand parachain. Transactions can be submitted to the collator node and they enter the transaction pool. When you like to execute these transactions, an order can be placed on Rococo relay chain for the parachain block production and validation through onDemandAssignmentProvider pallet call. If you intend to have a parachain that produces blocks continously, you can purchase bulk coretime through awesome interfaces from Lastic or RegionX . For more details and tips on ordering coretime, see the ordering coretime page .","title":"Launching on Rococo"},{"location":"launch/#launching-on-rococo","text":"OpenZepppelin Polkadot Generic Runtime Template was chosen as a candidate for launching Educhain. They crafted the pallet list to be as minimalistic and preserved important pallets that are used in the Polkadot ecosystem. Their docs serve as a good starting point to understand the launch process of a parachain on Polkadot testnet Rococo.","title":"Launching on Rococo"},{"location":"launch/#personalize-template","text":"In a single shot, you can (almost) rebrand the runtime template to your own project by replacing the occurrences of parachain-runtime and parachain_runtime with your project name. You may also add, remove, or create new pallets and add them to the runtime. Adding new pallets involves correctly configuring their associated types and ensuring they are a part of the construct_runtime! macro. You can view more about h ow pallets work in the Polkadot SDK docs.","title":"Personalize Template"},{"location":"launch/#set-genesis-config","text":"It is common that most of the tutorials and templates use Alice or Bob keys for the root, collator and session keys. It is obvious that these should be replaced by custom keys. It is recommended that you use an account created on a cold wallet for the root account. It is also important for the collator key and its session key to be different. The collator key is recommended to be created on a cold wallet and the session key can be generated from a hot wallet, as you need to enter its seed/private key into the collator's key store to start producing blocks. The session keys are rotated often for this reason. The genesis config can be used to also configure the initial state of your pallets. For more information on the genesis config, see these Polkadot SDK docs. For generating a chain spec, you can either view our process here or refer to the corresponding Polkadot SDK docs.","title":"Set Genesis Config"},{"location":"launch/#collator-node-setup","text":"You can spin up a collator on your local machine or on a cloud instance of your choice. Educhain node runs as a Digital Ocean droplet . If you like to interact with your collator through the Polkadot JS UI , the connection needs to be secured via SSL. This requires securing a domain (such as web3educhain.xyz) and then setting up SSL to access your Droplet (or other VPS) for the RPC address to be able to interact with it using Polkadot JS UI. Securing via SSL requires a proxy setup for the RPC interfaces of your node. See the collator section of this wiki to learn more about launching collators.","title":"Collator Node Setup"},{"location":"launch/#block-production","text":"Educhain is deployed on Rococo as an on-demand parachain. Transactions can be submitted to the collator node and they enter the transaction pool. When you like to execute these transactions, an order can be placed on Rococo relay chain for the parachain block production and validation through onDemandAssignmentProvider pallet call. If you intend to have a parachain that produces blocks continously, you can purchase bulk coretime through awesome interfaces from Lastic or RegionX . For more details and tips on ordering coretime, see the ordering coretime page .","title":"Block Production"},{"location":"ordering-coretime/","text":"Ordering Coretime There are two types of coretime: Bulk coretime - rent computation for an amount of time in advance (i.e., 28 days), requires renewal. On-demand coretime - buy computation on-demand on a per block basis, requires sending an extrinsic to order a block. For EduChain, we mostly use on-demand coretime and place order when we need to test something. Ordering on-demand coretime Ordering via CLI You can use the polkadot-js-api to call any extrinsic, including on-demand coretime for your parachain. Ensure you have it installed: yarn global add @polkadot/api-cli # or npm -g install @polkadot/api-cli Once installed, you can send the extrinsic as follows. Be sure to supplement a seed phrase with ROC ( faucet here ) and also replace PARA_ID with your parachain's ID on Rococo: polkadot-js-api tx.onDemandAssignmentProvider.placeOrderAllowDeath \\ 1000000000000 \\ PARA_ID \\ --seed \"your seed here\" \\ --ws \"wss://rococo-rpc.polkadot.io\" If you wanted, you could even do something a bit silly, such as have a shell script which orders a block every six seconds: while : do polkadot-js-api tx.onDemandAssignmentProvider.placeOrderAllowDeath \\ 1000000000000 \\ PARA_ID \\ --seed \"your seed here\" \\ --ws \"wss://rococo-rpc.polkadot.io\" sleep 6 done Ordering via PolkadotJS Use the following guides to order on-demand coretime through PolkadotJS. Ordering Bulk Coretime Use the following guides to order bulk coretime.","title":"Ordering Coretime"},{"location":"ordering-coretime/#ordering-coretime","text":"There are two types of coretime: Bulk coretime - rent computation for an amount of time in advance (i.e., 28 days), requires renewal. On-demand coretime - buy computation on-demand on a per block basis, requires sending an extrinsic to order a block. For EduChain, we mostly use on-demand coretime and place order when we need to test something.","title":"Ordering Coretime"},{"location":"ordering-coretime/#ordering-on-demand-coretime","text":"","title":"Ordering on-demand coretime"},{"location":"ordering-coretime/#ordering-via-cli","text":"You can use the polkadot-js-api to call any extrinsic, including on-demand coretime for your parachain. Ensure you have it installed: yarn global add @polkadot/api-cli # or npm -g install @polkadot/api-cli Once installed, you can send the extrinsic as follows. Be sure to supplement a seed phrase with ROC ( faucet here ) and also replace PARA_ID with your parachain's ID on Rococo: polkadot-js-api tx.onDemandAssignmentProvider.placeOrderAllowDeath \\ 1000000000000 \\ PARA_ID \\ --seed \"your seed here\" \\ --ws \"wss://rococo-rpc.polkadot.io\" If you wanted, you could even do something a bit silly, such as have a shell script which orders a block every six seconds: while : do polkadot-js-api tx.onDemandAssignmentProvider.placeOrderAllowDeath \\ 1000000000000 \\ PARA_ID \\ --seed \"your seed here\" \\ --ws \"wss://rococo-rpc.polkadot.io\" sleep 6 done","title":"Ordering via CLI"},{"location":"ordering-coretime/#ordering-via-polkadotjs","text":"Use the following guides to order on-demand coretime through PolkadotJS.","title":"Ordering via PolkadotJS"},{"location":"ordering-coretime/#ordering-bulk-coretime","text":"Use the following guides to order bulk coretime.","title":"Ordering Bulk Coretime"},{"location":"upgrade/","text":"Upgrading Your Runtime \u26a0\ufe0f You need access to a sudo account to authorize and apply upgrades! Every parachain runtime (that is, the code inside of src/runtime/* ) can be boiled down to a single .wasm blob. This blob is what the relay chain uses to validate state transitions from the parachain's collators. Part of the reason behind this design was the concept of forkless upgrades, where essentially we can replace the WebAssembly blob with another, upgraded version. On solo chains, it's usually as easy as calling system.setCode(new_wasm) , which quite literally replaces the WebAssembly runtime with another within the storage layer of the node(s) and will be utilized after the extrinsic is executed. On a parachain, the process is essentially two steps instead of one due to the involvement of the relay chain, which must be notified before you upgrade your parachain's code using the system.authorizeUpgrade extrinsic, then you can apply that upgrade using system.applyAuthorizedUpgrade . This lets the relay chain know that: An upgrade is going to commence, and it expects a new state transition function for validation The upgrade / new code gets applied. Compiling your WASM Blob Getting your WASM blob is as simple as compiling your runtime: cargo build --release Your blob should be under target/release/wbuild/educhain-runtime/educhain_runtime.compressed.wasm Obtaining your runtime hash Since system.authorizeUpgrade requires a Blake2b_256 hash of the runtime, which you can get via this tool. . You can also get the hash of the file via the system.authorizeUpgrade extrinsic in the PolkadotJS UI, and hash the file there. Upgrade Via PolkadotJS With your hash, authorize the upgrade ( system.authorizeUpgrade ) (replace HASH_HERE with your new hash and YOUR_RPC_HERE with your RPC URL). Keep in mind this done on the parachain: If you're using on-demand coretime, ensure you order a block accordingly. You should see the upgrade being queued. Call system.applyAuthorizedUpgrade and upload your compressed (i.e., educhain_runtime.compressed.wasm ) WASM blob. Be sure to also order coretime if needed! Upgrade Via Substrate Frontend \u26a0\ufe0f You will need to clone a modified version of the template in order to perform this upgrade! Change src/config/development.json to feature your node as well! This requires a few more steps, but you could also use the frontend template's upgrade function. Remember to still use the pallet interactor to authorize the upgrade.","title":"Upgrading Your Runtime"},{"location":"upgrade/#upgrading-your-runtime","text":"\u26a0\ufe0f You need access to a sudo account to authorize and apply upgrades! Every parachain runtime (that is, the code inside of src/runtime/* ) can be boiled down to a single .wasm blob. This blob is what the relay chain uses to validate state transitions from the parachain's collators. Part of the reason behind this design was the concept of forkless upgrades, where essentially we can replace the WebAssembly blob with another, upgraded version. On solo chains, it's usually as easy as calling system.setCode(new_wasm) , which quite literally replaces the WebAssembly runtime with another within the storage layer of the node(s) and will be utilized after the extrinsic is executed. On a parachain, the process is essentially two steps instead of one due to the involvement of the relay chain, which must be notified before you upgrade your parachain's code using the system.authorizeUpgrade extrinsic, then you can apply that upgrade using system.applyAuthorizedUpgrade . This lets the relay chain know that: An upgrade is going to commence, and it expects a new state transition function for validation The upgrade / new code gets applied.","title":"Upgrading Your Runtime"},{"location":"upgrade/#compiling-your-wasm-blob","text":"Getting your WASM blob is as simple as compiling your runtime: cargo build --release Your blob should be under target/release/wbuild/educhain-runtime/educhain_runtime.compressed.wasm","title":"Compiling your WASM Blob"},{"location":"upgrade/#obtaining-your-runtime-hash","text":"Since system.authorizeUpgrade requires a Blake2b_256 hash of the runtime, which you can get via this tool. . You can also get the hash of the file via the system.authorizeUpgrade extrinsic in the PolkadotJS UI, and hash the file there.","title":"Obtaining your runtime hash"},{"location":"upgrade/#upgrade-via-polkadotjs","text":"With your hash, authorize the upgrade ( system.authorizeUpgrade ) (replace HASH_HERE with your new hash and YOUR_RPC_HERE with your RPC URL). Keep in mind this done on the parachain: If you're using on-demand coretime, ensure you order a block accordingly. You should see the upgrade being queued. Call system.applyAuthorizedUpgrade and upload your compressed (i.e., educhain_runtime.compressed.wasm ) WASM blob. Be sure to also order coretime if needed!","title":"Upgrade Via PolkadotJS"},{"location":"upgrade/#upgrade-via-substrate-frontend","text":"\u26a0\ufe0f You will need to clone a modified version of the template in order to perform this upgrade! Change src/config/development.json to feature your node as well! This requires a few more steps, but you could also use the frontend template's upgrade function. Remember to still use the pallet interactor to authorize the upgrade.","title":"Upgrade Via Substrate Frontend"}]}